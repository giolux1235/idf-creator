"""
Base class for IDF generators.
Provides common functionality shared by IDFGenerator and ProfessionalIDFGenerator.
"""
from datetime import datetime
from typing import Set, Optional, Dict
import math


class BaseIDFGenerator:
    """Base class for IDF generators with common functionality."""
    
    def __init__(self, version: str = "24.2"):
        """
        Initialize base IDF generator.
        
        Args:
            version: EnergyPlus version string (default: 24.2 to match EnergyPlus 24.2.0)
        """
        self.version = version
        self.unique_names: Set[str] = set()
        self._outdoor_air_node_emitted = False
        self._outdoor_air_nodelist_emitted = False
    
    def _generate_unique_name(self, base_name: str) -> str:
        """
        Generate a unique object name in the IDF.
        
        Args:
            base_name: Base name for the object
            
        Returns:
            Unique name (base_name if available, otherwise base_name_N)
        """
        if base_name not in self.unique_names:
            self.unique_names.add(base_name)
            return base_name
        
        counter = 1
        while f"{base_name}_{counter}" in self.unique_names:
            counter += 1
        
        unique_name = f"{base_name}_{counter}"
        self.unique_names.add(unique_name)
        return unique_name
    
    def reset_unique_names(self) -> None:
        """Reset the unique names set (useful for generating multiple IDFs)."""
        self.unique_names.clear()
        self._outdoor_air_node_emitted = False
        self._outdoor_air_nodelist_emitted = False
    
    def generate_header(self, generator_name: str = "IDF Creator") -> str:
        """
        Generate IDF file header.
        
        Args:
            generator_name: Name of the generator tool
            
        Returns:
            Header string for IDF file
        """
        return f"""! EnergyPlus IDF File
! Generated by {generator_name}
! Version: {self.version}
! Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

"""
    
    def generate_version_section(self) -> str:
        """
        Generate Version section.
        
        Returns:
            Version section string
        """
        return f"""Version,
  {self.version};                    !- Version Identifier

"""
    
    def _format_comment(self, text: str) -> str:
        """
        Format a comment line.
        
        Args:
            text: Comment text
            
        Returns:
            Formatted comment string
        """
        return f"  !- {text}"
    
    def _format_field(self, value: Optional[str], comment: Optional[str] = None) -> str:
        """
        Format an IDF field with optional comment.
        
        Args:
            value: Field value
            comment: Optional comment
            
        Returns:
            Formatted field string
        """
        if comment:
            return f"  {value},{self._format_comment(comment)}"
        return f"  {value},"
    
    def normalize_node_name(self, node_name: str) -> str:
        """
        Normalize node name to uppercase for EnergyPlus compatibility.
        EnergyPlus is case-sensitive for node names, so we normalize to uppercase
        to ensure consistency across all node references.
        
        Args:
            node_name: Node name to normalize
            
        Returns:
            Uppercase node name
        """
        return node_name.upper() if node_name else node_name

    def generate_outdoor_air_node(self, node_name: str = "SITE OUTDOOR AIR NODE") -> str:
        """
        Generate an OutdoorAir:Node object so global outdoor air references
        (e.g. availability managers) have a valid sensor node.
        """
        key = f"OUTDOORAIR:NODE::{node_name.upper()}"
        if key in self.unique_names or self._outdoor_air_node_emitted:
            return ""
        self.unique_names.add(key)
        self._outdoor_air_node_emitted = True
        return f"""OutdoorAir:Node,
  {node_name};                !- Name

"""

    def generate_outdoor_air_node_list(
        self,
        list_name: str = "Outdoor Air Node List",
        node_name: str = "SITE OUTDOOR AIR NODE"
    ) -> str:
        """
        Generate an OutdoorAir:NodeList object referencing the shared outdoor node.
        """
        key = f"OUTDOORAIR:NODELIST::{list_name.upper()}"
        if key in self.unique_names or self._outdoor_air_nodelist_emitted:
            return ""
        self.unique_names.add(key)
        self._outdoor_air_nodelist_emitted = True
        return f"""OutdoorAir:NodeList,
  {list_name},                !- Name
  {node_name};                !- Node Name 1

"""

    # ------------------------------------------------------------------
    # Shared sizing period helpers
    # ------------------------------------------------------------------
    def _default_design_day_parameters(self, climate_zone: Optional[str]) -> Dict[str, float]:
        """
        Provide conservative default design day parameters when weather file
        metadata is unavailable.

        The values are coarse but fall inside ASHRAE recommendations for each
        climate zone category. They ensure EnergyPlus sizing runs complete
        instead of terminating when design conditions are missing.
        """
        zone_key = None
        if climate_zone:
            for char in str(climate_zone):
                if char.isdigit():
                    zone_key = char
                    break
        zone_defaults = {
            '1': {'heating_dry_bulb': 18.0, 'heating_wet_bulb': 16.0,
                  'heating_wind_speed': 3.0, 'heating_wind_direction': 0.0,
                  'cooling_dry_bulb': 33.0, 'cooling_wet_bulb': 25.5,
                  'cooling_daily_range': 6.0, 'cooling_wind_speed': 3.0,
                  'cooling_wind_direction': 180.0},
            '2': {'heating_dry_bulb': 12.0, 'heating_wet_bulb': 10.0,
                  'heating_wind_speed': 3.5, 'heating_wind_direction': 0.0,
                  'cooling_dry_bulb': 35.0, 'cooling_wet_bulb': 24.0,
                  'cooling_daily_range': 8.0, 'cooling_wind_speed': 3.5,
                  'cooling_wind_direction': 200.0},
            '3': {'heating_dry_bulb': 4.0, 'heating_wet_bulb': 2.0,
                  'heating_wind_speed': 4.0, 'heating_wind_direction': 0.0,
                  'cooling_dry_bulb': 34.0, 'cooling_wet_bulb': 23.5,
                  'cooling_daily_range': 10.0, 'cooling_wind_speed': 4.0,
                  'cooling_wind_direction': 210.0},
            '4': {'heating_dry_bulb': -4.0, 'heating_wet_bulb': -6.0,
                  'heating_wind_speed': 4.5, 'heating_wind_direction': 0.0,
                  'cooling_dry_bulb': 32.0, 'cooling_wet_bulb': 22.0,
                  'cooling_daily_range': 11.0, 'cooling_wind_speed': 4.5,
                  'cooling_wind_direction': 220.0},
            '5': {'heating_dry_bulb': -12.0, 'heating_wet_bulb': -14.0,
                  'heating_wind_speed': 5.0, 'heating_wind_direction': 0.0,
                  'cooling_dry_bulb': 30.0, 'cooling_wet_bulb': 20.0,
                  'cooling_daily_range': 12.0, 'cooling_wind_speed': 5.0,
                  'cooling_wind_direction': 230.0},
            '6': {'heating_dry_bulb': -18.0, 'heating_wet_bulb': -20.0,
                  'heating_wind_speed': 5.5, 'heating_wind_direction': 0.0,
                  'cooling_dry_bulb': 28.0, 'cooling_wet_bulb': 18.0,
                  'cooling_daily_range': 13.0, 'cooling_wind_speed': 5.5,
                  'cooling_wind_direction': 240.0},
            '7': {'heating_dry_bulb': -26.0, 'heating_wet_bulb': -28.0,
                  'heating_wind_speed': 6.0, 'heating_wind_direction': 0.0,
                  'cooling_dry_bulb': 26.0, 'cooling_wet_bulb': 16.0,
                  'cooling_daily_range': 14.0, 'cooling_wind_speed': 6.0,
                  'cooling_wind_direction': 250.0},
            '8': {'heating_dry_bulb': -34.0, 'heating_wet_bulb': -36.0,
                  'heating_wind_speed': 6.5, 'heating_wind_direction': 0.0,
                  'cooling_dry_bulb': 24.0, 'cooling_wet_bulb': 14.0,
                  'cooling_daily_range': 15.0, 'cooling_wind_speed': 6.5,
                  'cooling_wind_direction': 260.0},
        }

        defaults = zone_defaults.get(zone_key, zone_defaults['4'])

        # Return a copy to prevent accidental mutation
        return dict(defaults)

    def _estimate_barometric_pressure(self, elevation_m: Optional[float]) -> float:
        """
        Estimate barometric pressure (Pa) from elevation using the ICAO standard
        atmosphere equation. Falls back to sea-level pressure when elevation is
        missing.
        """
        if elevation_m is None:
            return 101325.0
        try:
            elevation = float(elevation_m)
        except (TypeError, ValueError):
            return 101325.0

        # Exponential drop in pressure with altitude (scale height ~8434.5 m)
        return 101325.0 * math.exp(-elevation / 8434.5)

